---
layout: post
title: A Critique of Code Memes
---

_The examples here are written in Elm, the original language of the `RemoteData` 
pattern. Like the pattern itself, the thinking can be generalized to other 
languages._

## I. What is a code meme?

I'm not certain that code memes exist.
I have a hard time defining the idea and unlike Justice Stewart, I am 
uncomfortable asserting the reality of something that escapes definition.
"Code meme" is a label I give to some bits of programming I encounter on 
Twitter.
The technical content of the code meme is a readymade response to a common 
experience, a macro of thought, rigidly copied from one context to the next. 
Like any meme, a code meme suddenly seems to be everywhere at once until 
suddenly it is nowhere at all.

Not every use of a programming pattern is mimetic.
Programmers often adapt a pattern to a problem.
Then the pattern informs but does not dictate the result.
Code memes defy adaptation.
Perhaps the most well-known code meme is the "Hello World" program.
"Hello World" is a readymade solution to the problem of what program to write 
when beginning to learn a new language.
The thought expressed by the code is unmodified.
Only details like language and implementation change.

Here I will outline my experience using a code meme to solve a problem and then 
speculate a little on why this pattern became a meme.

## II. RemoteData is a code meme

The code meme _Slaying a UI Antipattern in X_ refers to the 
`RemoteData` pattern for modeling data generated by a REST request. 
<sup><a href="#1">1</a>,</sup>
<sup><a href="#2">2</a>,</sup>
<sup><a href="#3">3</a>,</sup>
<sup><a href="#4">4</a>,</sup>
<sup><a href="#5">5</a></sup>
User interfaces generally present this kind of data, "remote data", in one of 
four states: not loaded, loading, error, and success.
It's common for UI programmers to derive these states from a model with this
shape: 

```elm
type alias Model = 
  { xs : List x
  , isLoading : Bool
  , error : e
  }
```

`RemoteData` improves on this approach by encoding the state of the data 
into the data's type:

```elm
type alias Model = 
    { xs : RemoteData
    }

type RemoteData 
    = NotAsked
    | Loading
    | Failure e
    | Success (List x)
```

Making the state explicit has two benefits. 
First, the state is universally consistent and clear.
There is no risk that a developer will incorrectly derive an implicit state.
Second, consumers of the data are required to handle every state:

```elm
view : Model -> Html a
view { xs } =
    case xs of
        NotAsked ->
            --... 
        Loading ->
            --... 
        Failure error ->
            --... 
        Success data ->
            --... 
```

This code will not compile unless the patterns of the case statement cover 
every possible state.
The result is a system that is robust by default.

## III. RemoteData does not model all possible states

`RemoteData` insufficiently models the domain of remote data.
Imagine an application that displays a list of Foos.
The first request is to `/api/foos`.
The API responds with an array of Foos.
To save bandwidth, each Foo in the response is an abbreviated representation.
The application correctly sets `model.foos` first to `NotAsked`, then
to `Loading`, and finally to `Success (List Foo)`.
Meanwhile, the user interface transitions from an empty screen to a loading 
screen to a list of Foos.

All is well until the user clicks on one Foo in the list.
Now the list should show additional details about the clicked Foo.
But some of those details aren't available. 
The app only loaded abbreviated Foos.
So a loading indicator should appear next to the list item while more data is 
loaded from `/api/foos/[id]`.
Instead, the app jumps back to the loading screen.
Then the loading state resolves again to the list view.
But now the list of Foos is shortened to a list of one Foo with details.
To see the complete list again, the user must refresh the page.

The problem is loss of context.
When the user clicks into the detail view, a request is started and `model.foos`
is correctly set to `Loading`.
But there is only one `Loading` state, the same `Loading` state for which the 
`view` function renders the first loading screen. 
The app jumps back to the first loading screen because it cannot distinguish
between loading the Foos collection and loading Foo details.
Then the request for Foo details is complete and `model.foos` is again set to 
`Success (List Foo)`.
But the request for details only returns a single Foo. `model.foos` is now 
a list of one.
Data loaded during the first Foos request was lost in the transformation of
`model.foos` from `Success (List x)` to `Loading` to `Success (List x)`.
There is no way to keep the data that was loaded during the first Foos 
collection request.

`RemoteData` is an insufficient pattern because it attempts to model a 
_stateful_ cache of data in terms of a _stateless_ transfer of data, REST.
Because `RemoteData` is stateless, the pattern makes it impossible to model 
many possible states. 
These states include:

- Empty and error
- Empty, general error, and request pending
- Empty, general error, and request pending for subset of data
- Empty, error for subset of data, and request pending
- Empty, error for subset of data, and request pending for subset of data
- Data cached and general error
- Data cached and error for subset of data
- Data cached and request pending
- Data cached and request pending for subset of data
- Data cached, general error, and request pending
- Data cached, general error, and request pending for subset of data
- Data cached, error for subset of data, and request pending
- Data cached, error for subset of data, and request pending for subset of data

## IV. RemoteData as a state machine

The original blog post about `RemoteData` effectively demonstrates the power of
union types.
We can use that understanding to...
We can attempt to salvage the `RemoteData` pattern by modeling the optional 
cached error and cached data:

```elm
type RemoteData 
    = NotAsked
    | Loading (Maybe e) (Maybe (List x))
    | Failure e (Maybe (List x))
    | Success (Maybe e) (List x)
```

To associate the error or the loading state with a subset of the data (e.g. 
one item in the collection), we have to include an optional id.

```elm
    | Loading (Maybe e, Maybe Int) (Maybe Int) (Maybe (List x)) 
    | Failure e (Maybe Int) (Maybe (List x)) 
```

For the sake of readability, this gets refactored to a couple of state 

```elm
type alias LoadingState = 
    { xs : Maybe (List x)
    , error : (Maybe Int, Maybe e)
    , id : Maybe Int -- Just Int when loading one item
    }

type alias FailureState =
    { xs : Maybe (List x)
    , error : (Maybe Int, e) -- (Just Int, e) when the error is for one item
    }

type alias SuccessState = 
    { xs : List x
    , error : (Maybe Int, Maybe e)
    }

type RemoteData
    = NotAsked
    | Loading LoadingState
    | Failure FailureState
    | Success SuccessState
```

Unfortunately, the model has regressed from explicit to implicit representation
of the cache's state.
`RemoteData` is not an effective pattern for modeling a remote data 
cache.

<!--
`RemoteData` effectively demonstrates the power of union types.
The power of union types is well-demonstrated by the `RemoteData` pattern.
-->

```
+-------------------------------+
| Empty Pending                 |<-+-----+-----+
+-------------------------------+  |     |     |
                                   |     |     |
Pending----------------------------+     |     |
Success------------------------------+   |     |
Error----------------------------------+ |     |
                                     | | |     |
                                     | | |     |
+-------------------------------+    | | |     |
| Empty Valid                   |    | | |     |
+-------------------------------+    | | |     |
                                     | | |     |
Pending----------------------------------+     |
Success------------------------------------+   |
Error----------------------------------------+ |
                                     | |   | | |
                                     | |   | | | 
+-------------------------------+    | |   | | |
| Empty (Invalid e)             |<-----+-----+-----+
+-------------------------------+    |     |   |   |
                                     |     |   |   |
Pending----------------------------------------+   |
Success------------------------------------------+ |
Error----------------------------------------------+
                                     |     |     |
                                     |     |     |
+-------------------------------+    |     |     |
| Primed Pending Collection     |<---------------|---+-----+-----+
+-------------------------------+    |     |     |   |     |     |
                                     |     |     |   |     |     |
Pending----------------------------------------------+     |     |
Success------------------------------------------------+   |     |
Error----------------------------------------------------+ |     |
                                     |     |     |     | | |     |
                                     |     |     |     | | |     |
+-------------------------------+    |     |     |     | | |     | 
| Primed (Valid d) Collection   |<---+-----+-----+-----+-|-|-+---|-+
+-------------------------------+                        | | |   | |
                                                         | | |   | |
Pending----------------------------------------------------+ |   | |
Success------------------------------------------------------+   | |
Error----------------------------------------------------------+ | |
                                                         |     | | |
                                                         |     | | |
+-------------------------------+                        |     | | |
| Primed (Invalid e) Collection |<-----------------------+-----+-|-|-+
+-------------------------------+                                | | |
                                                                 | | |
Pending----------------------------------------------------------+ | |
Success------------------------------------------------------------+ |
Error----------------------------------------------------------------+
```


**Footnotes**

<ol>
  <li>
    <fn id="1">
      <a href="http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html">
        How Elm Slays a UI Antipattern
      </a>
      by Kris Jenkins, the first to describe this pattern.
    </fn>
  </li>
  <li>
    <fn id="2">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-fantasyland-907cbc322d2a">
        Slaying a UI Antipattern in Fantasyland
      </a>
    </fn>
  </li>
  <li>
    <fn id="3">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-react-64a3b98242c">
        Slaying a UI Antipattern in React
      </a>
    </fn>
  </li>
  <li>
    <fn id="4">
      <a href="https://medium.com/@gcanti/slaying-a-ui-antipattern-with-flow-5eed0cfb627b">
        Slaying a UI Antipattern in Flow
      </a>
    </fn>
  </li>
  <li>
    <fn id="5">
      <a href="https://gist.github.com/busypeoples/b8982f215642e5258d3d49a9aa7d7438">
        Slaying a UI Antipattern in ReasonML
      </a>
    </fn>
  </li>
</ol>
