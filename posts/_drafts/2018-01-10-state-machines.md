---
layout: post
title: Critique of a Code Meme
---

_The examples here are written in Elm, the original language of the `RemoteData` 
pattern. Like the pattern itself, the thinking can be generalized to other 
languages._

## I. What is a code meme?

I'm not certain that code memes exist.
I have a hard time defining the idea and unlike Justice Stewart, I am 
uncomfortable asserting the reality of something that escapes definition.
"Code meme" is a label I give to some bits of programming I encounter on 
Twitter.
The technical content of the code meme is a readymade response to a common 
experience, a macro of thought, rigidly copied from one context to the next. 
Like any meme, a code meme suddenly seems to be everywhere at once until 
suddenly it is nowhere at all.

Not every use of a programming pattern is mimetic.
Programmers often adapt a pattern to a problem.
Then the pattern informs but does not dictate the result.
Code memes defy adaptation.
Perhaps the most well-known code meme is the _Hello World_ program.
_Hello World_ is a readymade solution to the problem of what program to write 
when beginning to learn a new language.
The thought expressed by the code is unmodified.
Only details like language or implementation change.

## II. RemoteData is a code meme

The code meme _Slaying a UI Antipattern in..._ refers to the `RemoteData` 
pattern.
<sup><a href="#1">1</a>,</sup>
<sup><a href="#2">2</a>,</sup>
<sup><a href="#3">3</a>,</sup>
<sup><a href="#4">4</a>,</sup>
<sup><a href="#5">5</a></sup>
To invoke the meme as "Slaying a UI Antipattern in Elm" means to show an 
Elm implementation of `RemoteData`.
Like the _Hello World_ program, the implementation is used to sample the flavor
of the language, specifically the flavor of that language's union types.

The `RemoteData` pattern and the UI Antipattern are both approaches to modeling 
the state of data generated by a REST request.
User interfaces generally present remote data in states like not loaded, 
loading, error, and success.
The UI Antipattern represents these states implicitly.
The current state is derived from a model with roughly this shape:

```elm
type alias Model = 
  { xs : List X
  , isLoading : Bool
  , error : Error
  }
```

`RemoteData` improves on this approach by using a union type to make these 
states explicit.
The state of the data is encoded into the data's type:

```elm
type alias Model =
    { xs : RemoteData Error (List X)
    }


type RemoteData a b
    = NotAsked
    | Loading
    | Failure a
    | Success (List b)
```

Making the state explicit has two benefits. 
First, the state is universally consistent and clear.
There is no risk that a developer will incorrectly derive an implicit state.
Second, consumers of the data are required to handle every state:

```elm
view : Model -> Html a
view model =
    case model.xs of
        NotAsked ->
            emptyView

        Loading ->
            loadingView

        Failure error ->
            errorView error

        Success data ->
            successView data
```

This code will not compile unless the patterns of the case statement cover 
every possible state.
The result is a system that is robust by default.

## III. RemoteData does not model all possible states

`RemoteData` models a _stateful_ cache of data in terms of a _stateless_ 
transfer of data, REST.
The current state of a `RemoteData` value preserves none of its prior state.
For example, the transformation of `Success d` to `Loading` means that the 
information in `d` is lost.
To carry that information from `Success d` to `Loading` requires us to update
the `Loading` constructor to `Loading d` or `Loading (Maybe d)`.

Here we must recall the old adage: user interfaces are state machines.
Many common features demand a continuity of context.
For example, infinite scroll is a combination of `Success a` and `Loading`.
By breaking this continuity, `RemoteData` makes it impossible to model many 
legitimate states.
These states include:

- empty, general error, and request pending
- empty, general error, and request pending for a subset of the data
- empty, error for a subset of the data, and request pending
- empty, error for a subset of the data, and request pending for a subset of the 
  Data
- data cached and general error
- data cached and error for a subset of the data
- data cached and request pending
- data cached and request pending for a subset of the data
- data cached, general error, and request pending
- data cached, general error, and request pending for a subset of the data
- data cached, error for a subset of the data, and request pending
- data cached, error for a subset of the data, and request pending for a subset 
  of the data

<!--
This pattern has been useful for writing blog posts, tweets, and even a library. 
But it is hard for me to understand how anyone found it useful for writing user 
interfaces.
-->

We can attempt to salvage the `RemoteData` pattern by adding nullable error and
data parameters to the `Loading` and `Failure` states.

```elm
type RemoteData a b
    = NotAsked
    | Loading (Maybe a) (Maybe b)
    | Failure a (Maybe b)
    | Success (Maybe a) b
```

This enables us to model states that are a mix of loading, error, and data.
For example, the "data cached, general error, and request pending" state would
look like this:

```elm
Loading (Just error) (Just xs)
```

and the "empty, general error, and request pending" state would look like this:

```elm
Loading (Just error) Nothing
```

We can use a similar approach to associate the loading and error states with a 
subset of the data.
Here we assume a collection of items where each item is uniquely identified by a
string.
The relationship between the state and an item in the collection is made by 
adding a nullable string parameter to the `Loading` and `Failure` states.

```elm
type RemoteData a b
    = NotAsked
    | Loading (Maybe String) (Maybe a) (Maybe b)
    | Failure (Maybe String) a (Maybe b)
    | Success (Maybe a) b
```

But this approach only enables us to associate the error state or the loading 
state with one item at a time.
The approach does not enable us to relate a mix of states with multiple items in
the collection.
Nor can we relate multiple states to the same item at the same time. 
`Loading (Maybe String) (Maybe a) (Maybe b)` must become 
`Loading (Maybe String) (Maybe String, Maybe a) (Maybe b)` to associate both the
error and the loading state with an item in the collection.

We could continue to cram more information into the `RemoteData` type. 
Instead of using `Maybe a` for errors, we could use `Dict String a` for a 
collection of errors, keyed by item id.
And so on.
But I don't recommend it.
This path leads directly back to implicit states.
Any code that consumes a value of the `RemoteData` type will explode with the 
nested case statements required to derive the current state.

## IV.

<!--
We can attempt to salvage the `RemoteData` pattern by modeling an optional 
cached error and cached data:

`RemoteData` effectively demonstrates the power of union types.
The power of union types is well-demonstrated by the `RemoteData` pattern.

```
+-------------------------------+
| Empty Pending                 |<-+-----+-----+
+-------------------------------+  |     |     |
                                   |     |     |
Pending----------------------------+     |     |
Success------------------------------+   |     |
Error----------------------------------+ |     |
                                     | | |     |
                                     | | |     |
+-------------------------------+    | | |     |
| Empty Valid                   |    | | |     |
+-------------------------------+    | | |     |
                                     | | |     |
Pending----------------------------------+     |
Success------------------------------------+   |
Error----------------------------------------+ |
                                     | |   | | |
                                     | |   | | | 
+-------------------------------+    | |   | | |
| Empty (Invalid e)             |<-----+-----+-----+
+-------------------------------+    |     |   |   |
                                     |     |   |   |
Pending----------------------------------------+   |
Success------------------------------------------+ |
Error----------------------------------------------+
                                     |     |     |
                                     |     |     |
+-------------------------------+    |     |     |
| Primed Pending Collection     |<---------------|---+-----+-----+
+-------------------------------+    |     |     |   |     |     |
                                     |     |     |   |     |     |
Pending----------------------------------------------+     |     |
Success------------------------------------------------+   |     |
Error----------------------------------------------------+ |     |
                                     |     |     |     | | |     |
                                     |     |     |     | | |     |
+-------------------------------+    |     |     |     | | |     | 
| Primed (Valid d) Collection   |<---+-----+-----+-----+-|-|-+---|-+
+-------------------------------+                        | | |   | |
                                                         | | |   | |
Pending----------------------------------------------------+ |   | |
Success------------------------------------------------------+   | |
Error----------------------------------------------------------+ | |
                                                         |     | | |
                                                         |     | | |
+-------------------------------+                        |     | | |
| Primed (Invalid e) Collection |<-----------------------+-----+-|-|-+
+-------------------------------+                                | | |
                                                                 | | |
Pending----------------------------------------------------------+ | |
Success------------------------------------------------------------+ |
Error----------------------------------------------------------------+
```

I find _Hello World_ useful exactly because I don't have to cast about for an 
idea every time I want to try a language out.

for sampling the flavor of a language, even if the pattern itself is not really
useful, at least 
-->

**Notes**

<ol>
  <li>
    <fn id="1">
      <a href="http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html">
        How Elm Slays a UI Antipattern
      </a>
      by Kris Jenkins, the first to describe this pattern.
    </fn>
  </li>
  <li>
    <fn id="2">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-fantasyland-907cbc322d2a">
        Slaying a UI Antipattern in Fantasyland
      </a>
    </fn>
  </li>
  <li>
    <fn id="3">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-react-64a3b98242c">
        Slaying a UI Antipattern in React
      </a>
    </fn>
  </li>
  <li>
    <fn id="4">
      <a href="https://medium.com/@gcanti/slaying-a-ui-antipattern-with-flow-5eed0cfb627b">
        Slaying a UI Antipattern in Flow
      </a>
    </fn>
  </li>
  <li>
    <fn id="5">
      <a href="https://gist.github.com/busypeoples/b8982f215642e5258d3d49a9aa7d7438">
        Slaying a UI Antipattern in ReasonML
      </a>
    </fn>
  </li>
  <!--
  note about how it took me a long time to understand what "a user interface is a state machine" means
  -->
</ol>
