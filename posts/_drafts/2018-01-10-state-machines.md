---
layout: post
title: Critique of a Code Meme
---

_The examples here are written in Elm, the original language of the `RemoteData` 
pattern. Like the pattern itself, the thinking can be generalized to other 
languages._

## I. What is a code meme?

I'm not certain that code memes exist.
I have a hard time defining the idea and unlike Justice Stewart, I am 
uncomfortable asserting the reality of something that escapes definition.
"Code meme" is a label I give to some bits of programming I encounter on 
Twitter.
The technical content of the code meme is a readymade response to a common 
experience, a macro of thought, rigidly copied from one context to the next. 
Like any meme, a code meme suddenly seems to be everywhere at once until 
suddenly it is nowhere at all.

Not every use of a programming pattern is mimetic.
Programmers often adapt a pattern to a problem.
Then the pattern informs but does not dictate the result.
Code memes defy adaptation.
Perhaps the most well-known code meme is the _Hello World_ program.
_Hello World_ is a readymade solution to the problem of what program to write 
when beginning to learn a new language.
The thought expressed by the code is unmodified.
Only details like language or implementation change.

## II. RemoteData is a code meme

The code meme _Slaying a UI Antipattern in..._ refers to the `RemoteData` 
pattern.
<sup><a href="#1">1</a>,</sup>
<sup><a href="#2">2</a>,</sup>
<sup><a href="#3">3</a>,</sup>
<sup><a href="#4">4</a>,</sup>
<sup><a href="#5">5</a></sup>
To invoke the meme as "Slaying a UI Antipattern in Elm" means to show an 
Elm implementation of `RemoteData`.
Like the _Hello World_ program, the implementation is used to sample the flavor
of the language, specifically the flavor of that language's union types.

The `RemoteData` pattern and the UI Antipattern are both approaches to modeling 
the state of data generated by a REST request.
User interfaces generally present remote data in states like not loaded, 
loading, error, and success.
The UI Antipattern represents these states implicitly.
The current state is derived from a model with roughly this shape:

```elm
type alias Model = 
  { xs : List X
  , isLoading : Bool
  , error : Error
  }
```

`RemoteData` improves on this approach by using a union type to make these 
states explicit.
The state of the data is encoded into the data's type:

```elm
type alias Model =
    { xs : RemoteData Error (List X)
    }


type RemoteData a b
    = NotAsked
    | Loading
    | Failure a
    | Success (List b)
```

Making the state explicit has two benefits. 
First, the state is universally consistent and clear.
There is no risk that a developer will incorrectly derive an implicit state.
Second, consumers of the data are required to handle every state:

```elm
view : Model -> Html a
view model =
    case model.xs of
        NotAsked ->
            emptyView

        Loading ->
            loadingView

        Failure error ->
            errorView error

        Success data ->
            successView data
```

This code will not compile unless the patterns of the case statement covers 
every possible state.
The result is a system that is robust by default.

## III. RemoteData does not model all possible states

`RemoteData` models a _stateful_ cache of data in terms of a _stateless_ 
transfer of data, REST.
The current state of a `RemoteData` value preserves none of its prior state.
For example, the transformation of `Success d` to `Loading` means that the 
information in `d` is lost.
To carry that information from `Success d` to `Loading` requires us to update
the `Loading` constructor to `Loading d` or `Loading (Maybe d)`.

Here we must recall the old adage: user interfaces are state machines.
Many common features demand a continuity of context.
For example, infinite scroll is a combination of `Success a` and `Loading`.
By breaking this continuity, `RemoteData` makes it impossible to model many 
legitimate states.
These states include:

- empty, general error, and request pending
- empty, general error, and request pending for a subset of the data
- empty, error for a subset of the data, and request pending
- empty, error for a subset of the data, and request pending for a subset of the 
  Data
- data cached and general error
- data cached and error for a subset of the data
- data cached and request pending
- data cached and request pending for a subset of the data
- data cached, general error, and request pending
- data cached, general error, and request pending for a subset of the data
- data cached, error for a subset of the data, and request pending
- data cached, error for a subset of the data, and request pending for a subset 
  of the data

We can attempt to salvage the `RemoteData` pattern by adding nullable error and
data parameters to the `Loading` and `Failure` states.

```elm
type RemoteData a b
    = NotAsked
    | Loading (Maybe a) (Maybe b)
    | Failure a (Maybe b)
    | Success (Maybe a) b
```

This enables us to model states that are a mix of loading, error, and data.
For example, the "data cached, general error, and request pending" state would
look like this:

```elm
Loading (Just error) (Just xs)
```

and the "empty, general error, and request pending" state would look like this:

```elm
Loading (Just error) Nothing
```

We can use a similar approach to associate the loading and error states with a 
subset of the data.
Here we assume a collection of items where each item is uniquely identified by a
string.
The relationship between the state and an item in the collection is made by 
adding a nullable string parameter to the `Loading` and `Failure` states.

```elm
type RemoteData a b
    = NotAsked
    | Loading (Maybe String) (Maybe a) (Maybe b)
    | Failure (Maybe String) a (Maybe b)
    | Success (Maybe a) b
```

But this approach only enables us to associate the error state or the loading 
state with one item at a time.
The approach does not enable us to relate a mix of states with multiple items in
the collection.
Nor can we relate multiple states to the same item at the same time. 
`Loading (Maybe String) (Maybe a) (Maybe b)` must become 
`Loading (Maybe String) (Maybe String, Maybe a) (Maybe b)` to associate both the
error and the loading state with an item in the collection.

We could continue to cram more information into the `RemoteData` type. 
Instead of using `Maybe a` for errors, we could use `Dict String a` for a 
collection of errors, keyed by item id.
And so on.
But I don't recommend it.
This path leads directly back to implicit states.
Any code that consumes a value of the `RemoteData` type will explode with the 
nested case statements required to derive the current state.

## IV. Inefficient-meme hypothesis

The efficient-market hypothesis states that prices always reflect all available 
information.
I propose an inefficient-meme hypothesis: a meme never reflects all available 
information.
As an utterance becomes more and more memetic, it is a map corresponding less 
and less to the terrain.

Edsger Dijkstra famously defined programming as "the art of organizing 
complexity, of mastering multitude".
In organizing complexity, we cannot make our programs less complex than they 
need to be.
As programmers, we should be wary of code memes.
The inefficient-meme hypothesis suggests that the code meme masters multitudes
by leaving some of those multitudes out.

## V. An alternative

It is tempting to sign off here, at the conclusion of my critique.
But the critique does not solve the problem of modeling the states of a remote 
data cache.
I work a lot on user interfaces.
Whether or not I use the remote data pattern, I still want to solve that 
problem.
So here is an alternative approach to modeling these states. 
This is an experimental approach. 
I'm not sure that it is a sane approach. 
I am always suspicious that there is a simpler way and glad to hear when there 
is.

The core of this problem is an insufficient number of states.
Even a relatively simple user interface requires many more than the four states 
of `RemoteData`.
There are two kinds of missing state.
The first kind of missing state is compound state.
Even a relatively simple user interface displays states that are a mix of 
"empty", "loading", "error", and "success".
Let's start by defining those states.

```elm
type Cache a b
    = Empty
    | EmptyInvalid a
    | EmptySyncing
    | EmptyInvalidSyncing a
    | Filled b
    | FilledSyncing b
    | FilledInvalid a b
    | FilledInvalidSyncing a b
```

The second kind of missing state is specific state.
The state of a collection and the state of an item in that collection are not 
always the same.
For example, an application might load a list of data first and then later make 
a request for details about one item in that list.
Then only the  item, not the collection, should be in the `FilledSyncing` state.

General and specific states are achieved by creating a cache of caches.
Imagine that we are fetching data from a People API.
For every `Person`, we'll create a `PersonCache`.
Then we'll store each `PersonCache` in a `Dict` keyed by `Person` id.
Finally, we'll create a `Cache` for this `PersonCollection`.
General states are managed by the outer cache.
Specific states are managed by the inner caches.

```elm
type alias Person =
    { name : String
    }


type alias PersonCache =
    Cache Http.Error Person


type alias PersonCollection =
    Dict String PersonCache


type alias Model =
    { persons : Cache Http.Error PersonCollection
    }
```

All possible states are represented.
But when will the cache change its current state?
The cache will change its state in response to a `CacheEvent`.
Our cache will respond to three events: the start of a request to the remote 
data source and resolutions of that request to an error or data.

```elm
type CacheEvent a b
    = Sync
    | Error a
    | Update b
```

## VI. What is a finite state machine?

Every combination of cache state and cache event results in a new cache state.
All states and all events are known, and all state changes are knowable too.
For example, a cache in the `Empty` state should change to `EmptyInvalid a`
when an `Error a` event occurs.
Here is a table that shows how each state should change in response to each 
event.

```
State                    | Sync                     | Error             | Update
-----------------------------------------------------------------------------------
Empty                    | EmptySyncing             | EmptyInvalid a    | Filled b
EmptyInvalid a           | EmptyInvalidSyncing a    | EmptyInvalid a    | Filled b
EmptySyncing             | EmptySyncing             | EmptyInvalid a    | Filled b
EmptyInvalidSyncing a    | EmptyInvalidSyncing a    | EmptyInvalid a    | Filled b
Filled b                 | FilledSyncing b          | FilledInvalid a b | Filled b
FilledSyncing b          | FilledSyncing b          | FilledInvalid a b | Filled b
FilledInvalid a b        | FilledInvalidSyncing a b | FilledInvalid a b | Filled b
FilledInvalidSyncing a b | FilledInvalidSyncing a b | FilledInvalid a b | Filled b
```

We know what the states are, when the states change, and how the states change.
In fact, we have specified a finite state machine.
A finite state machine has three components: states, events, and transitions.
An event prompts the finite state machine to transition from its current state 
to a new state.
The finite state machine makes the correct transition by testing conditions at 
the time of the event.
In our case, these conditions are all the combinations of states and events 
found in our state change table.

A simplified Elm `update` function closely resembles a simple state machine: 

```elm
type Msg
    = Increment
    | Decrement
    | Reset


type alias Model =
    Int


update : Msg -> Model -> Model
update msg model =
    case msg of
        Increment ->
            model + 1

        Decrement ->
            model - 1

        Reset ->
            0
```

The `Msg` is like an event, the `Model` is like a state, and each branch of the 
case expression is a transition from the current state to the next state.
A major difference between this `update` function and a finite state machine is 
that `update` produces an infinite number of states.
Without upper and lower bounds, `update` can return any member of the infinitely
large set of integers.

## VII. A remote-data cache is a state machine


**Notes**

<ol>
  <li>
    <fn id="1">
      <a href="http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html">
        How Elm Slays a UI Antipattern
      </a>
      by Kris Jenkins, the first to describe this pattern.
    </fn>
  </li>
  <li>
    <fn id="2">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-fantasyland-907cbc322d2a">
        Slaying a UI Antipattern in Fantasyland
      </a>
    </fn>
  </li>
  <li>
    <fn id="3">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-react-64a3b98242c">
        Slaying a UI Antipattern in React
      </a>
    </fn>
  </li>
  <li>
    <fn id="4">
      <a href="https://medium.com/@gcanti/slaying-a-ui-antipattern-with-flow-5eed0cfb627b">
        Slaying a UI Antipattern in Flow
      </a>
    </fn>
  </li>
  <li>
    <fn id="5">
      <a href="https://gist.github.com/busypeoples/b8982f215642e5258d3d49a9aa7d7438">
        Slaying a UI Antipattern in ReasonML
      </a>
    </fn>
  </li>
  <!--
  note about how it took me a long time to understand what "a user interface is a state machine" means
  -->
  <li>
  https://en.wikiquote.org/wiki/Edsger_W._Dtra
  </li>
</ol>

<!--
Now we have represented all the states of our cache.
This becomes it's own 

Like the `RemoteData` pattern, our remote data cache is a system for tagging
data from a remote data source with one of a limited number of states.
This cache has two requirements.
First, the cache must represent every possible state explicitly.
Second, the cache must change that state in response to external input.
The cache is not responsible for updating the data itself and it should not 
depend on any one type of data.

define an explicit state
enumerate every possible state explicitly.
The cache should define an explicit state for every possible state of the cahce. 
of the states listed above.
The set of this states will be larger than the set of `RemoteData` states but
they will not be infinitely more.
All states are knowable in advance
First, the cache should define a limited number of discrete cache states.
These are general states such as empty, loading, and error; states applicable 
describe any data from a remote data source that is cached by the application.


,could be any states that make sense for the application.
These states will be more than the four states of `RemoteData` but they will not
be infinitely more.
All states are knowable in advance.
Second, the cache should know how to change the current state to the next state 
in response to external input.
The focus of the cache is on the states of the data and not the data itself.
The cache should be compatible with any kind of data whose state is reasonably 
described by the states of the cache.

This approach models a cache of remote data as a finite state machine.
A finite state machine is useful 
A remote data cache has a relatively small number of states 
The remote data cache is always in a 
is always in a single state
A finite state machine is a 
A finite state machine is an pattern used to model the state of a system that 
exists in one state at a time
-->

<!--
Every combination of state and event is knowable in advacne
The condition for every new state is a combination of current state and event.

and an `Error a` event occurs, the state
of the cache should change to 
The combination of the `Empty` state and the `Error a` event
, the new state of 

From any combination of state and event, we can know the next state.

Given any state and any event, how do we know the next state? 
what is the next state?

The last question is "how does the state change?"

Changing the state of a `RemoteData` cache was unsophisticated.

Changing the state of a `RemoteData` cache was easy because the last state was
always discarded
the last state was 
discarded and the next state was
because the pattern does not distinguish between states and events.
A loading event simply set the state of the cache to loading.
Changing the state of our cache is more complicated because we have compound 
states.
Transitioning from one compound state to another compound state requires 

Every combination of state and event produces a new state.
All of these combinations are knowable


The next state of the cache will always depend on the current state and the 
event.


The next state was always easy to predict.
Our state changes will be more complicated but no less predictable.
kkk

We can begin to answer that question by thinking about what those changes will 
be.
Our state changes will be deterministic.
Given a known state and a known event, the next state is also knowable.

For that reason, every new state resulting from a state change is knowable.

Every next state are knowable.

We can start to answer this question by listing what states we want. 
-->
