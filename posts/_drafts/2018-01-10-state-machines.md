---
layout: post
title: Critique of a Code Meme
---

_The examples here are written in Elm, the original language of the `RemoteData` 
pattern. Like the pattern itself, the thinking can be generalized to other 
languages._

## I. What is a code meme?

I'm not certain that code memes exist.
I have a hard time defining the idea and unlike Justice Stewart, I am 
uncomfortable asserting the reality of something that escapes definition.
"Code meme" is a label I give to some bits of programming I encounter on 
Twitter.
The technical content of the code meme is a readymade response to a common 
experience, a macro of thought, rigidly copied from one context to the next. 
Like any meme, a code meme suddenly seems to be everywhere at once until 
suddenly it is nowhere at all.

Not every use of a programming pattern is mimetic.
Programmers often adapt a pattern to a problem.
Then the pattern informs but does not dictate the result.
Code memes defy adaptation.
Perhaps the most well-known code meme is the _Hello World_ program.
_Hello World_ is a readymade solution to the problem of what program to write 
when beginning to learn a new language.
The thought expressed by the code is unmodified.
Only details like language or implementation change.

## II. RemoteData is a code meme

The code meme _Slaying a UI Antipattern in..._ refers to the `RemoteData` 
pattern.
<sup><a href="#1">1</a>,</sup>
<sup><a href="#2">2</a>,</sup>
<sup><a href="#3">3</a>,</sup>
<sup><a href="#4">4</a>,</sup>
<sup><a href="#5">5</a></sup>
To invoke the meme as "Slaying a UI Antipattern in Elm" means to show an 
Elm implementation of `RemoteData`.
Like the _Hello World_ program, the implementation is used to sample the flavor
of the language, specifically the flavor of that language's union types.

The `RemoteData` pattern and the UI Antipattern are both approaches to modeling 
the state of data generated by a REST request.
User interfaces generally present remote data in states like not loaded, 
loading, error, and success.
The UI Antipattern represents these states implicitly.
The current state is derived from a model with roughly this shape:

```elm
type alias Model = 
  { xs : List x
  , isLoading : Bool
  , error : e
  }
```

`RemoteData` improves on this approach by using a union type to make these 
states explicit.
The state of the data is encoded into the data's type:

```elm
type alias Model = 
    { xs : RemoteData
    }

type RemoteData 
    = NotAsked
    | Loading
    | Failure e
    | Success (List x)
```

Making the state explicit has two benefits. 
First, the state is universally consistent and clear.
There is no risk that a developer will incorrectly derive an implicit state.
Second, consumers of the data are required to handle every state:

```elm
view : Model -> Html a
view { xs } =
    case xs of
        NotAsked ->
            --... 
        Loading ->
            --... 
        Failure error ->
            --... 
        Success data ->
            --... 
```

This code will not compile unless the patterns of the case statement cover 
every possible state.
The result is a system that is robust by default.

## III. RemoteData does not model all possible states

`RemoteData` models a _stateful_ cache of data in terms of a _stateless_ 
transfer of data, REST.
The current state of a `RemoteData` value preserves none of its prior state.
For example, the transformation of `Success d` to `Loading` means that the 
information in `d` is lost.
To carry that information from `Success d` to `Loading` requires us to update
the `Loading` constructor to `Loading d` or `Loading (Maybe d)`.

Here we must recall the old adage: user interfaces are state machines.
Many common features demand a continuity of context.
For example, infinite scroll is a combination of `Success d` and `Loading`.
By breaking this continuity, `RemoteData` makes it impossible to model many 
legitimate states.
These states include:

- Empty, general error, and request pending
- Empty, general error, and request pending for a subset of the data
- Empty, error for a subset of the data, and request pending
- Empty, error for a subset of the data, and request pending for a subset of the 
  data
- Data cached and general error
- Data cached and error for a subset of the data
- Data cached and request pending
- Data cached and request pending for a subset of the data
- Data cached, general error, and request pending
- Data cached, general error, and request pending for a subset of the data
- Data cached, error for a subset of the data, and request pending
- Data cached, error for a subset of the data, and request pending for a subset 
  of the data

Union types are an excellent way to model a finite number of states.

```elm
type Cache a b c
    = Empty (Health a) (Sync b)
    | Filled (Health a) (Sync b) c


type Health a
    = Valid
    | Invalid a


type Sync a
    = Complete
    | Pending a
```

```elm
type alias Model =
    { foos : Cache Error Source (List Foo)
    }


type Error 
    = General String
    | Specific (Int, String)


type Source
    = Collection
    | Item Int
```

<!--
We can attempt to salvage the `RemoteData` pattern by modeling an optional 
cached error and cached data:

`RemoteData` effectively demonstrates the power of union types.
The power of union types is well-demonstrated by the `RemoteData` pattern.

```
+-------------------------------+
| Empty Pending                 |<-+-----+-----+
+-------------------------------+  |     |     |
                                   |     |     |
Pending----------------------------+     |     |
Success------------------------------+   |     |
Error----------------------------------+ |     |
                                     | | |     |
                                     | | |     |
+-------------------------------+    | | |     |
| Empty Valid                   |    | | |     |
+-------------------------------+    | | |     |
                                     | | |     |
Pending----------------------------------+     |
Success------------------------------------+   |
Error----------------------------------------+ |
                                     | |   | | |
                                     | |   | | | 
+-------------------------------+    | |   | | |
| Empty (Invalid e)             |<-----+-----+-----+
+-------------------------------+    |     |   |   |
                                     |     |   |   |
Pending----------------------------------------+   |
Success------------------------------------------+ |
Error----------------------------------------------+
                                     |     |     |
                                     |     |     |
+-------------------------------+    |     |     |
| Primed Pending Collection     |<---------------|---+-----+-----+
+-------------------------------+    |     |     |   |     |     |
                                     |     |     |   |     |     |
Pending----------------------------------------------+     |     |
Success------------------------------------------------+   |     |
Error----------------------------------------------------+ |     |
                                     |     |     |     | | |     |
                                     |     |     |     | | |     |
+-------------------------------+    |     |     |     | | |     | 
| Primed (Valid d) Collection   |<---+-----+-----+-----+-|-|-+---|-+
+-------------------------------+                        | | |   | |
                                                         | | |   | |
Pending----------------------------------------------------+ |   | |
Success------------------------------------------------------+   | |
Error----------------------------------------------------------+ | |
                                                         |     | | |
                                                         |     | | |
+-------------------------------+                        |     | | |
| Primed (Invalid e) Collection |<-----------------------+-----+-|-|-+
+-------------------------------+                                | | |
                                                                 | | |
Pending----------------------------------------------------------+ | |
Success------------------------------------------------------------+ |
Error----------------------------------------------------------------+
```

I find _Hello World_ useful exactly because I don't have to cast about for an 
idea every time I want to try a language out.

for sampling the flavor of a language, even if the pattern itself is not really
useful, at least 
-->

**Notes**

<ol>
  <li>
    <fn id="1">
      <a href="http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html">
        How Elm Slays a UI Antipattern
      </a>
      by Kris Jenkins, the first to describe this pattern.
    </fn>
  </li>
  <li>
    <fn id="2">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-fantasyland-907cbc322d2a">
        Slaying a UI Antipattern in Fantasyland
      </a>
    </fn>
  </li>
  <li>
    <fn id="3">
      <a href="https://medium.com/javascript-inside/slaying-a-ui-antipattern-in-react-64a3b98242c">
        Slaying a UI Antipattern in React
      </a>
    </fn>
  </li>
  <li>
    <fn id="4">
      <a href="https://medium.com/@gcanti/slaying-a-ui-antipattern-with-flow-5eed0cfb627b">
        Slaying a UI Antipattern in Flow
      </a>
    </fn>
  </li>
  <li>
    <fn id="5">
      <a href="https://gist.github.com/busypeoples/b8982f215642e5258d3d49a9aa7d7438">
        Slaying a UI Antipattern in ReasonML
      </a>
    </fn>
  </li>
  <!--
  note about how it took me a long time to understand what "a user interface is a state machine" means
  -->
</ol>
